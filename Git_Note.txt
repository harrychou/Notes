http://git-scm.com/book
Pro Git

1. Getting Started

1.1 About Version Control

	A VCS allows you to: 
	* revert files back to a previous state, 
	* revert the entire project back to a previous state, 
	* review changes made over time, 
	* see who last modified something that might be causing a problem, 
	* who introduced an issue and when, 
	* and more. 

	Types of VCS (version control system)
	* Local http://git-scm.com/figures/18333fig0101-tn.png
		- RCS
	* Central http://git-scm.com/figures/18333fig0102-tn.png
		- CVS/Subversion/Perforce
		- Single Server contains all versions
		- Adv
			* collaboration
			* easy to admin
		- Disadv
			* single point of failure 
	* Distributed http://git-scm.com/figures/18333fig0103-tn.png
		- Git/Mercurial/Bazar/Darcs
		- Each client have full mirror of the respository
		- Each client or server can be used to restore/copy to each other
		- Enable more flexible workflow within project

1.2 A Short History of Git

	From Linux project
	* from 1991 to 2002 - just patches and archive files
	* from 2002 - use proprietary DVCS called BitKeeper
	* 2005 - BitKeeper company stop provide it free of charge
		- Linus Torvalds started developing their own tool
	* goals
		- speed
		- simple design
		- strong support for non-linear development
		  (thousand of parallel branches)
		- fully distributed
		- able to handle big project (Linux Kernel, speed and data size)

1.3 Git Basics

	Git Basic
	* Important to learn basics of how Git works
	* Git's way of thinking/handling info are very different - source of confusion

	What's different of Git from others
	* Other think in terms of files and changes to the files
		- http://git-scm.com/figures/18333fig0104-tn.png
	* Git thinks of its data more like a set of snapshots of a mini filesystem
		http://git-scm.com/figures/18333fig0105-tn.png
		- every commit is like taking a snashop
		- if one file has no change, just store pointer to previous file instead save the new file
		- Git more like a mini filesystem with some incredibly powerful tools built on top of it
		- the benefits will be covered when discussing Git branching

  Nearly Every Operation Is Local 
  * no need to have a remote server
  * you can do everything and enjoy the benefit of version control
  * fast - encouraged to check in

  Git Integrity
  * everything stored by checksum
  	- all changes are definitely tracked by Git
	* You can’t lose information in transit or get file corruption without Git being able to detect it.
	* SHA-1 hash
		- 40-char string
		- calculated based on the contents of a file or directory structure of Git
		- ex: 24b9da6552252987aa493b52f8696cd6d3b00373
	* Git store everything based on the hash string (which represents content) rather than file name

	Git only add data to repository
	* everything is undoable
	* very hard to lose data in Git

	Three state the files can reside in
	* three states
		- commited: safely saved to git database
		- modified
		- staged: marked a modified file in its version to go into commited snapshot
	* three main sections http://git-scm.com/figures/18333fig0106-tn.png
		- working directory
			* single checkout of one version
			* pulled out of compressed database from Git repository
		- staging area
			* a simple file
			* store information about what will go into next commit
			* aka: index
		- git directory (repository)
			* where git store metadata
			* database
			* copied to all repositories

1.4 Installing Git

	* from source
	* on Linux
	* on Mac
	* on Windows

1.5 First-Time Git Setup

	one-time setup, but can update anytime

	git config
	* main tool to control Git
	* tool to setup variables
	* the info are stored in three places:
		(more specific place trumps the general one)
		- /etc/gitcofnig
			* git config --system
			* shared by all users
			* C:\Program Files (x86)\Git\etc\gitconfig
		- ~/.gitconfig
			* C:\Users\c00522\.gitconfig
			* only for you
			* git config --global
		- .git/config
			* only for that repository

	Things to config
	* identity
		- git config --global user.name "Harry Chou"
		- git config --global user.email "harrychou@gmail.com"
	* editor
		- git config --global core.editor emacs
	* diff
		- git config --global merge.tool vimdiff

	display configs
	* git config --list
	* git config re

1.6 Getting Help

	git help <verb>
	git <verb> --help
	man git-<verb>

1.7 Summary

2. Git Basics

	* covers all basic commands
	* configure/initialize repository
	* begin/stop tracking files
	* stage/commit changes
	* ignore files
	* file patterns
	* undo mistakes
	* browse history of the project
	* view changes between commits
	* push/pull from remote repository

2.1 Getting a Git Repository

	Two ways to get a git repository
	* add an existing directory into Git
	* clone an respository from remote

	git init
	* start tracking files in the existing directory
	* create .git folder
	* this is a skeleton
	* to start tracking
		- git add *.c
		- git add REAMME
		- git commit -m 'initial commit'

	git clone [url]
	* it's not checkout
		- checkout means getting a working copy
		- clone means getting the whole repository
		- server is just another place to store repository
	* ex: git clone git://github.com/user/repository1
	* what happens?
		- create a subdirectory repository1
		- initialize .git
		- pull down the data
		- check out a latest copy to be worked on
	* to clone into directory with another name
	  git clone [url] directoryName
	* git tranfer protocols
		- git://
		- http:// or https://
		- user@server:/path.git (SSH transfer)

2.2 Recording Changes to the Repository

	at some point of your work, you want to record your work as a version

	tracked/untracked fiels
	* tracked files: 
		- files in last snapshot or staged to go into next snapshot
		- can be in the state of: unmodifed, modified, staged
	* untracked files
		- files not in last snaphot and not staged

	check the status of the files
	* git status
	* by default should be 'nothing to commit'

	adding a new file
	* after adding a new file -> the file is untracked
	* to track it
	  git add filename
	* now the file is tracked and staged
	* to track directory (recursively)
	  git add directoryName

	git add will stage the extact file while it is staged
	* if file modified after staged, it can be both modified and staged
	* when commit without git add again, the staged content will be committed
	* you have to stage again (git add) to be able to commit the later change

	ignore files
	* some files are transient and autogenerated 
	  --> you don't really want to record their history
	* use .ignore file with glob patterns
	* rules for glob patterns: 
		- Blank lines or lines starting with # are ignored.
		- Standard glob patterns work.
		- You can end patterns with a forward slash (/) to specify a directory.
		- You can negate a pattern by starting it with an exclamation point (!).

		# a comment - this is ignored
		# no .a files
		*.a
		# but do track lib.a, even though you're ignoring .a files above
		!lib.a
		# only ignore the root TODO file, not subdir/TODO
		/TODO
		# ignore all files in the build/ directory
		build/
		# ignore doc/notes.txt, but not doc/server/arch.txt
		doc/*.txt
		# ignore all .txt files in the doc/ directory
		doc/**/*.txt

	show difference (git diff)
	* two type of diff
		- compare working directory to staged are
		  (what has been changed but not staged yet)
		- compare stage area to repository
		  (what you plan to commit to what has already been committed)
	* git diff by default do first one
	* git diff --staged do the second one

	commit changes
	* git commit
	* by default will use default editor (git config --global core.editor) to add comment
	* git commit -m 'comment'
	* git commit -am 'comment'
		- allow you to skip the (git add)
		- only add tracked files (for untracked files you still need manual git add)

	remove files
	* by only delete the file, your repository still track the file
	* use git rm to untrack the file
		- if the file is added to the index already, 
		  you must force the removal with the -f option.
		- this is to make removing content from repository difficult
	* to only remove from staged area but not working directory
	  (so the file is still in local directory, but Git won't track it)
	  git rm --cached file
	* git rm can take pattern to remove multiple files

	mvoe files
	* git mv file_from file_to
	* same as
	  mv file_from file_to
	  git rm file_from
	  git add file_to
	* Git does not store rename file in metadata, git only try to figure that out after the fact
	* that means, you can rename using another tool and (git rm) (git add) to save to repository

2.3 Viewing the Commit History

	viewing the history of Git repository
	* git log
		- show all history with checksum, author , date
		- show in reverse order
	* git log -p -2
		- last 2 commits
		- -p show all diff
		- useful for code review and stuff
	* git log -U1 --word-diff
		- U1, show diff output of only one line
		- word-diff, show word difference
		  [-  ...  -] or {+  ....  +}
    * git log --stat
    	- shows the history with summary of 
    	- # of files changes...
    * git log --pretty=oneline|short|full|fuller
    	- change the format 
    * custom format
      $ git log --pretty=format:"%h - %an, %ar : %s"
      format options:
      	%H  Commit hash
		%h  Abbreviated commit hash
		%T  Tree hash
		%t  Abbreviated tree hash
		%P  Parent hashes
		%p  Abbreviated parent hashes
		%an Author name
		%ae Author e-mail
		%ad Author date (format respects the --date= option)
		%ar Author date, relative
		%cn Committer name
		%ce Committer email
		%cd Committer date
		%cr Committer date, relative
		%s  Subject
	* author vs commiter
		- author: who wrote the patch
		- commiter: who last applied the patch
	* to view log with graphi output
    git log --pretty=format:"%h %s" --graph

	Limiting log output
	* --since=2.weeks
	* --until=2.weeks
	* --author
	* --committer
	* example:
		git log --pretty="%h - %s" --author=gitster --since="2008-10-01" \
   --before="2008-11-01" --no-merges -- t/ 
		want to see which commits modifying test files in the Git source code history 
 		were committed by Junio Hamano in the month of October 2008 and were not merges, 

	use gitk
	* shows what git log shows
	* nice graph for ancestor
	* show diff on bottom left

2.4 Undoing Things

	How to get back to history?
	* warning: may lose work (one of the few area in Git)

	To Amend a commit
	* git commit -m 'initial commit'
		git add forgotten_file
		git commit --amend
	* this will forget the first commit and use the second commit as the only commit
	* can also use to change commit message
	
	Unstage a staged file
	* if you type git add ., but realize you want to keep modify one file
	* git reset HEAD filename

	Unmodify a modified file
	* if you want to revert the file back to what you first get from repository
	* git checkout -- filename
	* this will actually get rid of whatever you've changed
	* if want to keep a record somehow, use branch or stash

2.5 Working with Remotes

	Remote Repository
	* a repository that is hosted somewhere else (internet or some other machines)
	* can have many remote repositories
	* each of them can be read-only or read-write
	* managing remote repositories
		- add remote repository
		- remove ....
		- managing remote branches and define tracked or not

	git remote
	* by default show all the defined remotes
	* -v to show more info
	* show multiple remotes, withonly one with SSH for pushing to
		- this is to allow pulling from other branches, and pushing only to one

	to add a new remote repository
	* git remote add shortname url

	to get stuff from a remote repository
	* git fetch remote-name
		- pull down all data from the remote project that does not available locally
		- we will have local reference to all branches available remotely
		- we can then merge or inspect the branches
	* if you cloned the repsitory, you have 'origin' as the remote repository
	* fetch won't modify local work directory
		--> you have to merge it manually when OK
	
	git pull
	* you can have a branch setup to track remote branch
		(this is the default behavior when you have git clone - local master is tracking 'origin' master)
		in this case, you can use git pull to :
		- pull data
		- and merge automatically
		- and checkout to workign directory
	* your local master branch is tracking remote 'orignin' master
	
	git push [remote-name] [branch-name]
	* push your work upstream
	* git push origin master 
		(push my master branch back to remote-origin)
	* need write permission
	* cannot have more than two persons push at the same time
	* if someone else alreay pushed, your push will be rejected
		- you have to pull first and merge

	inspectig remote
	* to find more information about a remote
		git remote show origin
	* sample output
		remote origin
	  Fetch URL: https://github.com/harrychou/Notes.git
	  Push  URL: https://github.com/harrychou/Notes.git
	  HEAD branch: master
	  Remote branch:
	    master tracked
	  Local branch configured for 'git pull':
	    master merges with remote master
	  Local ref configured for 'git push':
	    master pushes to master (up to date)
	* other info are shown too

	Removing and Renaming Remotes
	* git remote rename to change remote's shortname
	* will change the reference of brannch -> pb/master is now at paul/master.
	* to remove
		git remote rm shortname
		- used when stop using a mirror or drop a contributor 

2.6 Tagging

	Tagging
	* also available in other VCSs
	* mark a specific point in history as important
	* generally used for marking a release point

	List all the tags
	* git tag
	* git tag -l 'v1.4.2.*'

	Types of tags
	* lightweight
		- just like a branch that doesn't change
		- just a point of a specific commit
	* annotated (recommended for more info)
		- stored as full objects
		- checksumed with all info (email, tagname, date)
		- have detailed message
		- can be signed and verified by GNU Privacy Guard

	Annotated tags
	* to create
		git tag -a v1.4 -m 'comment'
	* to view the tag
		git show v1.4
		- tagger
		- date
		- version ...

	signed tags
	* to sing a tag
		git tag -s v1.5 -m 'my signed 1.5 tag'
	* use GPG to sign
	* git show v1.5
		- will show PGP signature
	* you can later 'verify' the tag

	lightweight tags
	* basically the commit checksum stored in a file — no other information is kept
	* to create
		git tag v1.4.lw
	* git show v1.4 
		will only show simple info

	verify tags
	* git tag -v [tag-name]
	* need the signer’s public key in your keyring for this to work properly
	* if no signer’s public key, you get gpg error

	tag a past commit
	* git tag -a v1.2 -m 'comment' 964f16d36dfccde844893cac5b347e7b3d44abbc
		- 964f16d36dfccde844893cac5b347e7b3d44abbc is the checksum of the commit
	* to get the list of commit
		git log --pretty=oneline

	by default, tags are not pushed to remote
	* to push a tag you have to use
		git push origin v1.5
	* to push mulitple tags
		git push origin --tags	

2.7 Tips and Tricks

	Tips and Tricks to make using Git easier
	* just good to know, don't have to do these
	* Bash shell auto completion
		- in Git source / contrib/completion
		- git-completion.bash
	* windows shell integration
		- part of msysGit
	* autocomplete also works for options
		$ git log --s<tab>
		--shortstat  --since=  --src-prefix=  --stat   --summary
	* git allow you to create alias for common commands
		$ git config --global alias.co checkout
		$ git config --global alias.br branch
		$ git config --global alias.ci commit
		$ git config --global alias.st status
		- instead of git commit, just type git ci
		$ git config --global alias.unstage 'reset HEAD --'
		- $ git unstage fileA
			$ git reset HEAD fileA
		$ git config --global alias.last 'log -1 HEAD'
		- $ git last 
			(get the latest commit info)
	* use git alias to run external command
		$ git config --global alias.visual '!gitk'	

2.8 Summary

	basic local Git operation
	next -> killer feature > branching


Chapter 3

Chapter 3 Git Branching

	all VCs have branching
	* branching - used when diverge from the main line
	* separate from the changes of main line
	* often difficult for most VCs

	Git's branching is the killer feature
	* Git's branching is lightweight
	* making branching very easy and instaneous
	* Git encourse branching/merging as often as you like

3.1 Git Branching - What a Branch Is

	what is branch?
	* first need to understand how Git stores its data - a series of snapshots
	* when commit in Git, Git store a 'commit object' in database
		- the commit object has a pointer to the snapshot of the staged content/author/metadata
		- also, has pointer(s) to the parent commits
		- first commit does not have parent commit
		- multiple parents if it is a result of two or more branches
	* example - three file directory
		- first stage all three files 
			* create checksums for each file (SHA-1)
			* store the files as of current to staging (Git blobs)
			* checksums are added to stage area
		- when commit
			* checksum directory and all sub-dirs
			* store all three files to repoistory
			* a commit object is created to the root project tree
		- five objects are in Git repo now
			* three blobs (one for each file)
			* one tree for the contents of the directory with the file names that point to the files' blobs
			* one commit object with pointer to the tree object and the commit data
		- example: http://git-scm.com/figures/18333fig0301-tn.png

